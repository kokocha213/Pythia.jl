<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · Pythia.jl</title><meta name="title" content="API Reference · Pythia.jl"/><meta property="og:title" content="API Reference · Pythia.jl"/><meta property="twitter:title" content="API Reference · Pythia.jl"/><meta name="description" content="Documentation for Pythia.jl."/><meta property="og:description" content="Documentation for Pythia.jl."/><meta property="twitter:description" content="Documentation for Pythia.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Pythia.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/arma_generated/">Autoregressive Moving Average (ARMA): Artificial data</a></li><li><a class="tocitem" href="../examples/arma_sunspots/">Autoregressive Moving Average (ARMA): Sunspots data</a></li><li><a class="tocitem" href="../examples/stationarity_sun/">Stationarity and detrending (ADF/KPSS)</a></li></ul></li><li class="is-active"><a class="tocitem" href>API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ababii/Pythia.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>The following are the public functions, types, and methods exported by <code>Pythia</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.ARIMAModel" href="#Pythia.ARIMAModel"><code>Pythia.ARIMAModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ARIMAModel</code></pre><p>A comprehensive implementation of AutoRegressive Integrated Moving Average (ARIMA) models  with seasonal extensions (SARIMA), based on the Hyndman-Khandakar algorithm.</p><p>This implementation supports both automatic and manual model specification, with various  optimization strategies and information criteria for model selection.</p><p><strong>Mathematical Background</strong></p><p>ARIMA(p,d,q) × (P,D,Q)s models are defined by:</p><ul><li>φ(B)(1-B)^d Φ(B^s)(1-B^s)^D y<em>t = θ(B)Θ(B^s)ε</em>t + μ</li></ul><p>Where:</p><ul><li>φ(B) = 1 - φ₁B - φ₂B² - ... - φₚBᵖ (non-seasonal AR polynomial)</li><li>Φ(B^s) = 1 - Φ₁B^s - Φ₂B^{2s} - ... - ΦₚB^{Ps} (seasonal AR polynomial)  </li><li>θ(B) = 1 + θ₁B + θ₂B² + ... + θₑB^q (non-seasonal MA polynomial)</li><li>Θ(B^s) = 1 + Θ₁B^s + Θ₂B^{2s} + ... + ΘₖB^{Qs} (seasonal MA polynomial)</li><li>B is the backshift operator</li><li>ε_t ~ N(0,σ²) are white noise errors</li></ul><p><strong>References</strong></p><ul><li>Hyndman, R.J., &amp; Khandakar, Y. (2008). &quot;Automatic time series forecasting: the forecast package for R&quot;. Journal of Statistical Software, 26(3), 1-22.</li><li>Box, G.E.P., Jenkins, G.M., Reinsel, G.C., &amp; Ljung, G.M. (2015). &quot;Time Series Analysis: Forecasting and Control&quot;. 5th Edition.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.ARIMAModel-Tuple{AbstractVector{&lt;:Real}}" href="#Pythia.ARIMAModel-Tuple{AbstractVector{&lt;:Real}}"><code>Pythia.ARIMAModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ARIMAModel(y; kwargs...)</code></pre><p>Create an ARIMA model with automatic parameter selection capabilities.</p><p>This constructor implements the Hyndman-Khandakar algorithm for automatic ARIMA model  selection, which combines unit root tests, information criteria, and stepwise search  to find optimal model parameters.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector{&lt;:Real}</code>: Time series data (required)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>h::Int=5</code>: Forecast horizon (number of periods to forecast)</li><li><code>p::Union{Nothing,Int}=nothing</code>: Non-seasonal AR order (auto-determined if nothing)</li><li><code>d::Union{Nothing,Int}=nothing</code>: Non-seasonal differencing order (auto-determined if nothing)</li><li><code>q::Union{Nothing,Int}=nothing</code>: Non-seasonal MA order (auto-determined if nothing)</li><li><code>P::Union{Nothing,Int}=nothing</code>: Seasonal AR order (auto-determined if nothing)</li><li><code>D::Union{Nothing,Int}=nothing</code>: Seasonal differencing order (auto-determined if nothing)</li><li><code>Q::Union{Nothing,Int}=nothing</code>: Seasonal MA order (auto-determined if nothing)</li><li><code>s::Union{Nothing,Int}=nothing</code>: Seasonal period (e.g., 12 for monthly data)</li><li><code>seasonal::Bool=true</code>: Enable seasonal modeling</li><li><code>ic::String=&quot;aicc&quot;</code>: Information criterion (&quot;aic&quot;, &quot;aicc&quot;, &quot;bic&quot;)</li><li><code>loss::Function=sse_arima_loss_</code>: Loss function for parameter estimation</li><li><code>optimizer::Function=() -&gt; Optim.LBFGS()</code>: Optimization algorithm</li><li><code>stationary::Bool=false</code>: Assume series is already stationary</li><li><code>trace::Bool=false</code>: Print optimization progress</li><li><code>stepwise::Bool=true</code>: Use stepwise search (recommended for speed)</li><li><code>approximation::Bool=true</code>: Use CSS approximation for speed</li><li><code>max_p::Int=5</code>: Maximum non-seasonal AR order to consider</li><li><code>max_q::Int=5</code>: Maximum non-seasonal MA order to consider</li><li><code>max_P::Int=2</code>: Maximum seasonal AR order to consider</li><li><code>max_Q::Int=2</code>: Maximum seasonal MA order to consider</li><li><code>max_d::Int=2</code>: Maximum non-seasonal differencing order</li><li><code>max_D::Int=1</code>: Maximum seasonal differencing order</li><li><code>auto::Bool=true</code>: Enable automatic model selection</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic automatic ARIMA for quarterly data
y = [100, 102, 98, 105, 108, 110, 106, 112, 115, 118, 114, 120]
model = ARIMAModel(y; s=4)  # s=4 for quarterly seasonality

# Manual ARIMA(1,1,1) specification
model = ARIMAModel(y; p=1, d=1, q=1, auto=false)

# High-frequency data with custom settings
daily_data = rand(365) .+ sin.(2π * (1:365) / 365)  # Daily data with annual cycle
model = ARIMAModel(daily_data; 
                   s=365, 
                   h=30,           # 30-day forecast
                   max_p=3,        # Limit AR terms
                   max_q=3,        # Limit MA terms
                   approximation=false,  # Use exact ML
                   ic=&quot;bic&quot;)       # Use BIC for selection

# Non-seasonal ARIMA with custom optimizer
model = ARIMAModel(y; 
                   seasonal=false, 
                   optimizer=() -&gt; Optim.NelderMead(),
                   trace=true)</code></pre><p><strong>Mathematical Details</strong></p><p>The constructor implements the Hyndman-Khandakar algorithm:</p><ol><li>Determine differencing orders (d, D) using unit root tests</li><li>Select initial parameter values from a restricted set</li><li>Use stepwise search to explore neighboring parameter combinations</li><li>Select final model based on information criterion</li></ol><p><strong>References</strong></p><ul><li>Hyndman, R.J., &amp; Khandakar, Y. (2008). &quot;Automatic time series forecasting: the forecast package for R&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.SES" href="#Pythia.SES"><code>Pythia.SES</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>SES Description:     - Contains parameters and data to apply Simple Exponential Smoothing (SES)     - Subtype of ETSModel, for future proofing Constuctor:     - Vector{AbstractFloat} y: contains observations for forecasting     - Integer h: Stores the number of steps after time T to forecast (T = latest time in the observed data)         - Default = 10, must be &gt; 0     - Union{Nothing, Float64} alpha: smoothing parameter [1]         - 0 &lt; alpha &lt; 1         - If no value is specified, an optimal value will be chosen using LBFGS.     - Union{Nothing, Float64} init<em>level: initial level value [1]         -Inf &lt; init</em>level &lt; Inf         - If no value is specified, an optimal value will be chosen uisng LBFGS.</p><p>EXAMPLE USAGE:     observations = [1.0, 2.0, 3.0]     # Inputted values will be used if they are specified. Otherwise, they will be computed.     mdl = SES(observations, h = 5)      mdl = SES(observations, alpha = 0.4)      mdl = SES(observations, alpha = 0.25, init<em>level = 500.0)      mdl = SES(observations, h = 15, alpha = 0.3, init</em>level = 750.0)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.SSE_-Tuple{SES}" href="#Pythia.SSE_-Tuple{SES}"><code>Pythia.SSE_</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>SSE<em>()  Description:     - Returns the Sum of Squared Errors for a given alpha and init</em>level. Parameters:     - model: SES struct (defined above)     - alpha: value of alpha used for computation     - init<em>level: value of init</em>level used for computation     - verbose: if verbose &gt; 0, then the parameters will be printed as the are optimized. Returns:     - Float64 res: the Sum of Squared Errors for the given alpha and init_level values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.check_residuals-Tuple{Any}" href="#Pythia.check_residuals-Tuple{Any}"><code>Pythia.check_residuals</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_residuals(model; lag=24, plot_diagnostics=true)</code></pre><p>Diagnostic checks for ARIMA residuals.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: a fitted ARIMA model with residuals stored in <code>model.fitted_model.residuals</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>lag::Int = 24</code>: maximum lag for the ACF and Ljung-Box test.</li><li><code>plot_diagnostics::Bool = true</code>: whether to generate diagnostic plots.</li></ul><p><strong>Returns</strong></p><ul><li><code>plt::Plots.Plot</code> (or <code>nothing</code> if <code>plot_diagnostics=false</code>): the combined residual diagnostic plot.</li><li><code>pval::Float64</code>: Ljung–Box p-value for the residuals.</li></ul><p>This function does the following:</p><ol><li>Plots residual diagnostics (if <code>plot_diagnostics=true</code>):<ul><li>Residuals vs time</li><li>ACF of residuals with 95% confidence bands</li><li>Histogram of residuals with fitted Normal distribution overlay</li></ul></li><li>Computes the Ljung–Box test for white noise in residuals.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.cleanParams_" href="#Pythia.cleanParams_"><code>Pythia.cleanParams_</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>cleanParams_() Description:     Throws an error if a given parameters is out of the specified bounds. Parameters:     - param: value of parameter to be checked     - name: name of parameter to be checked     - lb: lower bound of parameter, default = 0.0     - ub: upper bound of parameter, defualt = 1.0 Note: if param is not of type Nothing, then param must be in (0.0, 1.0) Returns:     - nothing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.css_arima_loss_-Tuple{AbstractVector{&lt;:Real}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Int64}" href="#Pythia.css_arima_loss_-Tuple{AbstractVector{&lt;:Real}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Int64}"><code>Pythia.css_arima_loss_</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">css_arima_loss_(y, φ, θq, Φ, Θ, μ, s; return_residuals=false) -&gt; Float64 or Vector{Float64}</code></pre><p>Calculate the Conditional Sum of Squares (CSS) loss for ARIMA model parameters.</p><p>This is a fast approximation to maximum likelihood estimation that conditions on  initial values and computes the sum of squared residuals. It&#39;s particularly useful  for initial parameter estimation and model comparison.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector{&lt;:Real}</code>: Time series data</li><li><code>φ::Vector{Float64}</code>: Non-seasonal AR coefficients [φ₁, φ₂, ..., φₚ]</li><li><code>θq::Vector{Float64}</code>: Non-seasonal MA coefficients [θ₁, θ₂, ..., θₑ]</li><li><code>Φ::Vector{Float64}</code>: Seasonal AR coefficients [Φ₁, Φ₂, ..., Φₚ]</li><li><code>Θ::Vector{Float64}</code>: Seasonal MA coefficients [Θ₁, Θ₂, ..., Θₖ]</li><li><code>μ::Float64</code>: Intercept/mean parameter</li><li><code>s::Int</code>: Seasonal period</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>return_residuals::Bool=false</code>: Return residuals instead of sum of squares</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Sum of squared residuals (if return_residuals=false)</li><li><code>Vector{Float64}</code>: Residual series (if return_residuals=true)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Example for ARIMA(1,1,1)×(1,1,1)₁₂
y = [100, 102, 98, 105, 108, 110, 106, 112, 115, 118, 114, 120]
φ = [0.5]        # AR(1) coefficient
θq = [0.3]       # MA(1) coefficient  
Φ = [0.2]        # Seasonal AR(1) coefficient
Θ = [0.1]        # Seasonal MA(1) coefficient
μ = 0.0          # Mean (usually 0 for differenced data)
s = 12           # Monthly seasonality

# Calculate loss
loss = css_arima_loss_(y, φ, θq, Φ, Θ, μ, s)
println(&quot;CSS Loss: &quot;, loss)

# Get residuals
residuals = css_arima_loss_(y, φ, θq, Φ, Θ, μ, s; return_residuals=true)</code></pre><p><strong>Mathematical Formula</strong></p><p>The CSS approximation computes residuals as: eₜ = yₜ - μ - Σᵢ₌₁ᵖ φᵢyₜ₋ᵢ - Σᵢ₌₁ᵖ Φᵢyₜ₋ᵢₛ - Σⱼ₌₁ᵈ θⱼeₜ₋ⱼ - Σⱼ₌₁ᵈ Θⱼeₜ₋ⱼₛ</p><p>Loss = Σₜ₌ₘ₊₁ⁿ eₜ²</p><p>Where m = max(p, q, P×s, Q×s) is the maximum lag.</p><p><strong>References</strong></p><ul><li>Box, G.E.P., Jenkins, G.M., &amp; Reinsel, G.C. (2015). &quot;Time Series Analysis: Forecasting and Control&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.difference_series_-Tuple{AbstractVector{&lt;:Real}}" href="#Pythia.difference_series_-Tuple{AbstractVector{&lt;:Real}}"><code>Pythia.difference_series_</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">difference_series_(y; kwargs...) -&gt; NamedTuple</code></pre><p>Apply non-seasonal and seasonal differencing to achieve stationarity.</p><p>This function implements the differencing component of the Hyndman-Khandakar algorithm, using unit root tests to determine appropriate differencing orders.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector{&lt;:Real}</code>: Time series data</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>d::Union{Nothing,Int}=nothing</code>: Non-seasonal differencing order (auto-determined if nothing)</li><li><code>D::Union{Nothing,Int}=nothing</code>: Seasonal differencing order (auto-determined if nothing)</li><li><code>s::Union{Nothing,Int}=nothing</code>: Seasonal period</li><li><code>alpha::Float64=0.05</code>: Significance level for unit root tests</li><li><code>max_d::Int=2</code>: Maximum non-seasonal differencing order</li><li><code>max_D::Int=2</code>: Maximum seasonal differencing order</li><li><code>test::String=:kpss</code>: Unit root test for non-seasonal differencing</li><li><code>seasonal_test::String=:ocsb</code>: Unit root test for seasonal differencing</li><li><code>trend::Bool=true</code>: Include trend in unit root tests</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code>: Contains <code>y_diff</code> (final differenced series), <code>d</code> (applied non-seasonal order),  <code>D</code> (applied seasonal order), <code>y_diff_naive</code> (after non-seasonal differencing only)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Automatic differencing for monthly data
y = [100, 102, 98, 105, 108, 110, 106, 112, 115, 118, 114, 120]
result = difference_series_(y; s=12)
println(&quot;Applied d=&quot;, result.d, &quot;, D=&quot;, result.D)

# Manual differencing specification
result = difference_series_(y; d=1, D=1, s=12)
differenced_series = result.y_diff

# Non-seasonal differencing only
result = difference_series_(y; d=1, s=nothing)</code></pre><p><strong>Mathematical Background</strong></p><ul><li>Non-seasonal differencing: ∇ᵈyₜ = (1-B)ᵈyₜ</li><li>Seasonal differencing: ∇ˢᴰyₜ = (1-Bˢ)ᴰyₜ</li><li>Combined: ∇ᵈ∇ˢᴰyₜ = (1-B)ᵈ(1-Bˢ)ᴰyₜ</li></ul><p><strong>References</strong></p><ul><li>Kwiatkowski, D., Phillips, P.C.B., Schmidt, P., &amp; Shin, Y. (1992). &quot;Testing the null hypothesis of stationarity against the alternative of a unit root&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.dm_test-Tuple{Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#Pythia.dm_test-Tuple{Vector{&lt;:Real}, Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>Pythia.dm_test</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dm_test(actual, pred1, pred2; h=1, crit=&quot;MSE&quot;, power=2)</code></pre><p>Performs the Diebold-Mariano (DM) test to compare forecast accuracy between two prediction methods.</p><p><strong>Arguments</strong></p><ul><li><code>actual::Vector{&lt;:Real}</code>: The actual observed values.</li><li><code>pred1::Vector{&lt;:Real}</code>: The predicted values from model 1.</li><li><code>pred2::Vector{&lt;:Real}</code>: The predicted values from model 2.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>h::Int</code>: The forecast horizon (must be &gt; 0 and &lt; length of the input vectors).</li><li><code>crit::String</code>: Criterion to evaluate forecast errors. One of <code>&quot;MSE&quot;</code>, <code>&quot;MAD&quot;</code>, <code>&quot;MAPE&quot;</code>, or <code>&quot;poly&quot;</code>.</li><li><code>power::Real</code>: Used only when <code>crit=&quot;poly&quot;</code>, exponent to apply to the error.</li></ul><p><strong>Returns</strong></p><p>A NamedTuple: <code>(DM = test_statistic, p_value = p_value)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.fit-Tuple{ARIMAModel}" href="#Pythia.fit-Tuple{ARIMAModel}"><code>Pythia.fit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fit(model::ARIMAModel) -&gt; ARIMAModel</code></pre><p>Fit ARIMA model using the Hyndman-Khandakar automatic selection algorithm.</p><p>This is the main fitting function that implements the complete automatic ARIMA  algorithm, including differencing, parameter search, and model selection based  on information criteria.</p><p><strong>Arguments</strong></p><ul><li><code>model::ARIMAModel</code>: ARIMA model configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>ARIMAModel</code>: Fitted model with optimal parameters</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Automatic ARIMA for monthly data
y = [100, 102, 98, 105, 108, 110, 106, 112, 115, 118, 114, 120]
model = ARIMAModel(y; s=12)
fitted_model = fit(model)

println(&quot;Selected model: ARIMA(&quot;, fitted_model.p, &quot;,&quot;, fitted_model.d, &quot;,&quot;, fitted_model.q, &quot;)&quot;)
println(&quot;Seasonal: (&quot;, fitted_model.P, &quot;,&quot;, fitted_model.D, &quot;,&quot;, fitted_model.Q, &quot;)[&quot;, fitted_model.s, &quot;]&quot;)
println(&quot;AICc: &quot;, fitted_model.best_ic)

# Manual specification with fitting
model = ARIMAModel(y; p=1, d=1, q=1, auto=false)
fitted_model = fit(model)

# Custom settings for high-frequency data
daily_data = randn(365) .+ 0.1 * sin.(2π * (1:365) / 365)
model = ARIMAModel(daily_data; 
                   s=7,              # Weekly seasonality
                   stepwise=false,   # Full grid search
                   approximation=false,  # Exact ML
                   trace=true)       # Show progress
fitted_model = fit(model)</code></pre><p><strong>Algorithm Steps (Hyndman-Khandakar)</strong></p><ol><li>Determine differencing orders (d, D) using unit root tests</li><li>Select starting models from a restricted set</li><li>Use stepwise search around the best starting model</li><li>Select final model based on information criterion (AICc)</li></ol><p><strong>References</strong></p><ul><li>Hyndman, R.J., &amp; Khandakar, Y. (2008). &quot;Automatic time series forecasting: the forecast package for R&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.fit-Tuple{SES}" href="#Pythia.fit-Tuple{SES}"><code>Pythia.fit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>fit!(model::ETSModel) Description:     fits an ETSModel object     - computes initial values of parameters: &#39;alpha&#39; and &#39;init<em>value&#39;     - modifies the &#39;model&#39; directly.     - after fit! is called, predict(model) is ready to be called Parameters:     - model: SES struct     - v: verbosity, default = 0. if v &gt; 0, verbose will be used. Computation of model parameters: &#39;alpha&#39; and &#39;init</em>value&#39; are computed using LBFGS Returns:     - nothing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.fit_arima_manual_-Tuple{ARIMAModel}" href="#Pythia.fit_arima_manual_-Tuple{ARIMAModel}"><code>Pythia.fit_arima_manual_</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fit_arima_manual_(model::ARIMAModel) -&gt; ARIMAModel</code></pre><p>Fit ARIMA model parameters using nonlinear optimization.</p><p>This function estimates ARIMA parameters by minimizing the specified loss function  using the configured optimization algorithm. It handles parameter constraints and  computes model statistics.</p><p><strong>Arguments</strong></p><ul><li><code>model::ARIMAModel</code>: ARIMA model with specified orders and configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>ARIMAModel</code>: The same model with fitted parameters stored in <code>fitted_model</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Fit a specific ARIMA(1,1,1) model
y = [100, 102, 98, 105, 108, 110, 106, 112, 115, 118, 114, 120]
model = ARIMAModel(y; p=1, d=1, q=1, auto=false)
fitted_model = fit_arima_manual_(model)

# Access fitted parameters
params = fitted_model.fitted_model.params
println(&quot;Fitted parameters: &quot;, params)
println(&quot;Log-likelihood: &quot;, fitted_model.fitted_model.loglik)
println(&quot;Residual variance: &quot;, fitted_model.fitted_model.sigma2)

# Fit with custom optimizer
model = ARIMAModel(y; p=2, d=1, q=1, 
                   optimizer=() -&gt; Optim.NelderMead(),
                   auto=false)
fitted_model = fit_arima_manual_(model)</code></pre><p><strong>Mathematical Details</strong></p><p>The function optimizes the parameter vector θ = [μ, φ₁, ..., φₚ, θ₁, ..., θₑ, Φ₁, ..., Φₚ, Θ₁, ..., Θₖ] to minimize the loss function L(θ).</p><p>The intercept μ is included only when (d + D) &lt; 2.</p><p><strong>References</strong></p><ul><li>Nocedal, J., &amp; Wright, S. (2006). &quot;Numerical Optimization&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.get_ic-Tuple{ARIMAModel}" href="#Pythia.get_ic-Tuple{ARIMAModel}"><code>Pythia.get_ic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_ic(model::ARIMAModel) -&gt; Float64</code></pre><p>Calculate the corrected Akaike Information Criterion (AICc) for a fitted ARIMA model.</p><p>The AICc is particularly useful for small samples and is defined as: AICc = AIC + (2k(k+1))/(n-k-1)</p><p>Where:</p><ul><li>AIC = -2 * log-likelihood + 2k</li><li>k = number of parameters</li><li>n = sample size</li></ul><p><strong>Arguments</strong></p><ul><li><code>model::ARIMAModel</code>: A fitted ARIMA model</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The AICc value (lower is better)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Fit model and get AICc
model = ARIMAModel(y; p=1, d=1, q=1)
fitted_model = fit(model)
aicc_value = get_ic(fitted_model)
println(&quot;AICc: &quot;, aicc_value)</code></pre><p><strong>Mathematical Formula</strong></p><p>AICc = -2ℓ + 2k + (2k(k+1))/(n-k-1)</p><p>Where ℓ is the maximized log-likelihood.</p><p><strong>References</strong></p><ul><li>Hurvich, C.M., &amp; Tsai, C.L. (1989). &quot;Regression and time series model selection in small samples&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.inverse_difference-Tuple{Vector{Float64}, Float64, Int64}" href="#Pythia.inverse_difference-Tuple{Vector{Float64}, Float64, Int64}"><code>Pythia.inverse_difference</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inverse_difference(forecasts, y_last, d) -&gt; Vector{Float64}</code></pre><p>Reverse non-seasonal differencing transformation to convert forecasts back to original scale.</p><p>This function undoes the non-seasonal differencing operation (1-B)ᵈ by iteratively  computing cumulative sums.</p><p><strong>Arguments</strong></p><ul><li><code>forecasts::Vector{Float64}</code>: Forecasts in the differenced scale</li><li><code>y_last::Float64</code>: Last observation from the original series</li><li><code>d::Int</code>: Non-seasonal differencing order</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Forecasts transformed back to original scale</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># First difference (d=1)
forecasts = [0.5, 0.3, -0.2, 0.8]  # Forecasts in first-differenced scale
y_last = 120.0  # Last observation from original series
d = 1

# Transform back to original scale
original_forecasts = inverse_difference(forecasts, y_last, d)
println(&quot;Original scale forecasts: &quot;, original_forecasts)
# Output: [120.5, 120.8, 120.6, 121.4]

# Second difference (d=2)
forecasts = [0.1, 0.05, -0.02, 0.1]
y_last = 100.0
d = 2

original_forecasts = inverse_difference(forecasts, y_last, d)</code></pre><p><strong>Mathematical Formula</strong></p><p>For d = 1: yₜ = ∇yₜ + yₜ₋₁ = yₜ₋₁ + Σᵢ₌₁ᵗ ∇yᵢ For d = 2: yₜ = ∇²yₜ + 2yₜ₋₁ - yₜ₋₂</p><p>Where ∇ = (1-B) is the difference operator.</p><p><strong>References</strong></p><ul><li>Hamilton, J.D. (1994). &quot;Time Series Analysis&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.inverse_seasonal_difference-Tuple{Vector{Float64}, Vector{Float64}, Int64, Int64}" href="#Pythia.inverse_seasonal_difference-Tuple{Vector{Float64}, Vector{Float64}, Int64, Int64}"><code>Pythia.inverse_seasonal_difference</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inverse_seasonal_difference(forecasts, y_last, s, D) -&gt; Vector{Float64}</code></pre><p>Reverse seasonal differencing transformation to convert forecasts back to original scale.</p><p>This function undoes the seasonal differencing operation (1-Bˢ)ᴰ by iteratively  adding back the seasonal lags.</p><p><strong>Arguments</strong></p><ul><li><code>forecasts::Vector{Float64}</code>: Forecasts in the seasonally differenced scale</li><li><code>y_last::Vector{Float64}</code>: Last s×D observations from the original series</li><li><code>s::Int</code>: Seasonal period</li><li><code>D::Int</code>: Seasonal differencing order</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Forecasts transformed back to original scale</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Monthly data with one seasonal difference
forecasts = [0.1, 0.2, -0.1, 0.3]  # Forecasts in differenced scale
y_last = [100, 102, 98, 105, 108, 110, 106, 112, 115, 118, 114, 120]  # Last 12 months
s = 12  # Monthly seasonality
D = 1   # One seasonal difference

# Transform back to original scale
original_forecasts = inverse_seasonal_difference(forecasts, y_last, s, D)
println(&quot;Original scale forecasts: &quot;, original_forecasts)

# Quarterly data with two seasonal differences
forecasts = [0.05, 0.1, -0.02, 0.08]
y_last = [100, 102, 98, 105, 108, 110, 106, 112]  # Last 8 quarters
s = 4
D = 2

original_forecasts = inverse_seasonal_difference(forecasts, y_last, s, D)</code></pre><p><strong>Mathematical Formula</strong></p><p>For D = 1: yₜ = ∇ₛyₜ + yₜ₋ₛ For D = 2: yₜ = ∇ₛ²yₜ + 2yₜ₋ₛ - yₜ₋₂ₛ</p><p>Where ∇ₛ = (1-Bˢ) is the seasonal difference operator.</p><p><strong>References</strong></p><ul><li>Box, G.E.P., Jenkins, G.M., &amp; Reinsel, G.C. (2015). &quot;Time Series Analysis: Forecasting and Control&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.kpss_test-Tuple{AbstractVector{&lt;:Real}}" href="#Pythia.kpss_test-Tuple{AbstractVector{&lt;:Real}}"><code>Pythia.kpss_test</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kpss_test(y::AbstractVector{&lt;:Real};
          regression::String = &quot;c&quot;,
          nlags::Union{String, Int} = &quot;auto&quot;)</code></pre><p>Perform the KPSS test for level or trend stationarity.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series data (1D vector).</li><li><code>regression</code>: <code>&quot;c&quot;</code> for constant, <code>&quot;ct&quot;</code> for trend.</li><li><code>nlags</code>: <code>&quot;auto&quot;</code> (default, Hobijn-style), <code>&quot;legacy&quot;</code> (Schwert), or an integer.</li></ul><p><strong>Returns</strong></p><p>NamedTuple with:</p><ul><li><code>statistic</code>: KPSS test statistic</li><li><code>pvalue</code>: Approximate p-value</li><li><code>lags</code>: Lag used</li><li><code>critical_values</code>: Dict of critical values at 10%, 5%, 1%</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.makeForecast_-Tuple{SES}" href="#Pythia.makeForecast_-Tuple{SES}"><code>Pythia.makeForecast_</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>makeForecast<em>() Description:     - Helper function     - computes a forecast with Simple Exponential Smoothing (SES) [1] Parameters     - model: SES struct (defined above)     - Note: when makeForecast</em> is called, all parameters have been calibrated. Returns:     A tuple containing the following:     - Vector{Float64} forecast: contains fitted values     - SSE::Float64 SSE: the Sum of the Squares (error term)         - used for parameter optimzation References:      [1] Hyndman, R.J., &amp; Athanasopoulos, G. (2019) <em>Forecasting:         principles and practice</em>, 3rd edition, OTexts: Melbourne,         Australia. OTexts.com/fpp3. Accessed on April 19th 2020.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.plot_acf_pacf-Tuple{AbstractVector{&lt;:Real}}" href="#Pythia.plot_acf_pacf-Tuple{AbstractVector{&lt;:Real}}"><code>Pythia.plot_acf_pacf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_acf_pacf(y; lags=20, alpha=0.05) -&gt; Plot</code></pre><p>Compute and plot the autocorrelation function (ACF) and partial autocorrelation function (PACF)  for a univariate time series, including approximate confidence bounds.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector{&lt;:Real}</code>: Time series data</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>lags::Int=20</code>: Number of lags to compute and display for ACF and PACF</li><li><code>alpha::Float64=0.05</code>: Significance level for confidence bounds (default 95% confidence)</li></ul><p><strong>Returns</strong></p><ul><li><code>Plot</code>: Combined plot with ACF on top and PACF below, including confidence bounds</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using Random
Random.seed!(123)
y = randn(100)

# Default 20 lags with 95% confidence bounds
plot_acf_pacf(y)

# Custom number of lags
plot_acf_pacf(y, lags=30, alpha=0.01)</code></pre><p><strong>Notes</strong></p><ul><li>ACF includes lag 0, while PACF typically starts from lag 1.</li><li>The plots can help detect:<ul><li>Autoregressive (AR) structure: PACF cuts off after lag p</li><li>Moving average (MA) structure: ACF cuts off after lag q</li></ul></li></ul><p><strong>References</strong></p><ul><li>Box, G.E.P., Jenkins, G.M., &amp; Reinsel, G.C. (2015). <em>Time Series Analysis: Forecasting and Control</em>.</li><li>Brockwell, P.J., &amp; Davis, R.A. (2016). <em>Introduction to Time Series and Forecasting</em>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.plot_vectors-Tuple{Vector{&lt;:AbstractVector}, Vector{String}, Vector{Symbol}}" href="#Pythia.plot_vectors-Tuple{Vector{&lt;:AbstractVector}, Vector{String}, Vector{Symbol}}"><code>Pythia.plot_vectors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">plot_vectors(vectors::Vector{&lt;:AbstractVector}, 
             labels::Vector{String}, 
             colors::Vector{Symbol}; 
             linestyles::Union{Nothing, Vector{Symbol}} = nothing)</code></pre><p>Plot multiple vectors on the same plot. </p><p>Arguments:</p><ul><li><code>vectors</code>: A list of vectors to plot.</li><li><code>labels</code>: Labels for each line (used in the legend).</li><li><code>colors</code>: Line colors for each vector.</li></ul><p>Optional keyword:</p><ul><li><code>linestyles</code>: Optional line styles (e.g., <code>:solid</code>, <code>:dash</code>, <code>:dot</code>, etc.)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.predict-Tuple{ARIMAModel}" href="#Pythia.predict-Tuple{ARIMAModel}"><code>Pythia.predict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict(model::ARIMAModel; h=model.h,level) -&gt; NamedTuple{(:fittedvalues, :lower, :upper), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}}}</code></pre><p>Generate forecasts from a fitted ARIMA model.</p><p>This function produces point forecasts by iteratively applying the ARIMA equation  and then transforming back to the original scale by reversing any differencing operations.</p><p><strong>Arguments</strong></p><ul><li><code>model::ARIMAModel</code>: A fitted ARIMA model</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>h::Int=model.h</code>: Forecast horizon (number of periods to forecast)</li><li><code>level::Float64 = 0.95</code>: Confidence level for the forecast intervals.</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code> with:<ul><li><code>fittedvalues::Vector{Float64}</code>: Forecasted values on the original scale.</li><li><code>lower::Vector{Float64}</code>: Lower bounds of the prediction intervals.</li><li><code>upper::Vector{Float64}</code>: Upper bounds of the prediction intervals.</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Basic forecasting
y = [100, 102, 98, 105, 108, 110, 106, 112, 115, 118, 114, 120]
model = ARIMAModel(y; s=12, h=6)
fitted_model = fit(model)
results = predict(fitted_model)
forecasts = results.fittedvalues
lower = results.lower
upper = results.upper

# Display original data and forecasts
n = length(y)
println(&quot;Historical data: &quot;, y)
println(&quot;Forecasts: &quot;, forecasts)

# Custom forecast horizon
long_forecasts = predict(fitted_model; h=12)  # 12-period forecast

# Seasonal forecasting example
monthly_data = [100, 102, 98, 105, 108, 110, 106, 112, 115, 118, 114, 120,
                125, 128, 122, 132, 135, 138, 130, 142, 145, 148, 140, 155]
model = ARIMAModel(monthly_data; s=12, h=6)
fitted_model = fit(model)
results = predict(fitted_model)

# Extract just the forecast values
forecast_values = results.fittedvalues
println(&quot;6-month ahead forecasts: &quot;, forecast_values)</code></pre><p><strong>Mathematical Details</strong></p><p>For ARIMA(p,d,q)×(P,D,Q)ₓ, the h-step ahead forecast is: ŷₙ₊ₕ = μ + Σᵢ₌₁ᵖ φᵢŷₙ₊ₕ₋ᵢ + Σᵢ₌₁ᵖ Φᵢŷₙ₊ₓ₋ᵢₛ + Σⱼ₌₁ᵈ θⱼeₙ₊ₕ₋ⱼ + Σⱼ₌₁ᵈ Θⱼeₙ₊ₕ₋ⱼₛ</p><p>Where:</p><ul><li>Future errors eₙ₊ₖ = 0 for k &gt; 0</li><li>Past values and errors are used when available</li><li>Forecasts are used for future values in AR terms</li></ul><p><strong>References</strong></p><ul><li>Hyndman, R.J., &amp; Athanasopoulos, G. (2021). &quot;Forecasting: Principles and Practice&quot;</li><li>Box, G.E.P., Jenkins, G.M., &amp; Reinsel, G.C. (2015). &quot;Time Series Analysis: Forecasting and Control&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.predict-Tuple{Pythia.ETSModel}" href="#Pythia.predict-Tuple{Pythia.ETSModel}"><code>Pythia.predict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>predict() Description:     - Exposed function     - computes a forecast with Simple Exponential Smoothing (SES) [1]     - calls makeForecast_ a helper function, which returns a vector of fitted values and SSE error term. Parameters     - model: SES struct (defined above)     - Note: when predict is called, all parameters have been calibrated. Returns:     A tuple containing the following:     - Vector{Float64} forecast: contains fitted values References:      [1] Hyndman, R.J., &amp; Athanasopoulos, G. (2019) <em>Forecasting:         principles and practice</em>, 3rd edition, OTexts: Melbourne,         Australia. OTexts.com/fpp3. Accessed on April 19th 2020.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Pythia.sse_arima_loss_-Tuple{AbstractVector{&lt;:Real}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Int64}" href="#Pythia.sse_arima_loss_-Tuple{AbstractVector{&lt;:Real}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Float64, Int64}"><code>Pythia.sse_arima_loss_</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sse_arima_loss_(y, φ, θq, Φ, Θ, μ, s; return_residuals=false) -&gt; Float64 or Vector{Float64}</code></pre><p>Calculate the Sum of Squared Errors (SSE) loss for ARIMA model parameters.</p><p>This function provides exact maximum likelihood estimation by computing the full  likelihood function. It&#39;s more accurate than CSS but computationally more intensive.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector{&lt;:Real}</code>: Time series data</li><li><code>φ::Vector{Float64}</code>: Non-seasonal AR coefficients [φ₁, φ₂, ..., φₚ]</li><li><code>θq::Vector{Float64}</code>: Non-seasonal MA coefficients [θ₁, θ₂, ..., θₑ]</li><li><code>Φ::Vector{Float64}</code>: Seasonal AR coefficients [Φ₁, Φ₂, ..., Φₚ]</li><li><code>Θ::Vector{Float64}</code>: Seasonal MA coefficients [Θ₁, Θ₂, ..., Θₖ]</li><li><code>μ::Float64</code>: Intercept/mean parameter</li><li><code>s::Int</code>: Seasonal period</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>return_residuals::Bool=false</code>: Return residuals instead of sum of squares</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Sum of squared residuals (if return_residuals=false)</li><li><code>Vector{Float64}</code>: Residual series (if return_residuals=true)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Example for ARIMA(2,1,1) model
y = cumsum(randn(100)) + 0.1*(1:100)  # Random walk with drift
φ = [0.3, -0.2]   # AR(2) coefficients
θq = [0.4]        # MA(1) coefficient
Φ = Float64[]     # No seasonal AR
Θ = Float64[]     # No seasonal MA
μ = 0.1           # Small drift
s = 1             # No seasonality

# Calculate exact loss
loss = sse_arima_loss_(y, φ, θq, Φ, Θ, μ, s)
println(&quot;SSE Loss: &quot;, loss)

# Get residuals for diagnostic checking
residuals = sse_arima_loss_(y, φ, θq, Φ, Θ, μ, s; return_residuals=true)</code></pre><p><strong>Mathematical Formula</strong></p><p>The exact likelihood residuals are computed as: eₜ = yₜ - μ - Σᵢ₌₁ᵖ φᵢyₜ₋ᵢ - Σᵢ₌₁ᵖ Φᵢyₜ₋ᵢₛ - Σⱼ₌₁ᵈ θⱼeₜ₋ⱼ - Σⱼ₌₁ᵈ Θⱼeₜ₋ⱼₛ</p><p>For t = 1, 2, ..., n (handling initial conditions appropriately).</p><p><strong>References</strong></p><ul><li>Hamilton, J.D. (1994). &quot;Time Series Analysis&quot;</li><li>Brockwell, P.J., &amp; Davis, R.A. (2016). &quot;Introduction to Time Series and Forecasting&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ababii/Pythia.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/stationarity_sun/">« Stationarity and detrending (ADF/KPSS)</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Sunday 31 August 2025 08:54">Sunday 31 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
